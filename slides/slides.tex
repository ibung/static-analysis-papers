\documentclass[pdf]{beamer}
\mode<presentation>{\usetheme{Warsaw}}
\usepackage{listings}
\usepackage{amsmath, amssymb}

%% preamble
\title{Advanced Type-based Analysis}
\subtitle{Summary of Selected Papers}
\author[Nikita Ziuzin, Joachim Bard, Hizbullah Abdul Aziz]{Nikita Ziuzin\\
        Joachim Bard\\
        Hizbullah Abdul Aziz}

\AtBeginSection[]
{
  \begin{frame}{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}

\begin{document}
\begin{frame}
  \titlepage
\end{frame}

\section{Eliminating Array Bound Checking Through Dependent Types}

\begin{frame}
  \frametitle{Array bound checking}

  \begin{itemize}
    \item Absent in C
    \item Absence led to numerous problems in practice
    \item Memory-safe languages include it (Java, ML)
    \item Impose execution time costs when compiler cannot eliminate them
    \item Traditional compiler optimizations cannot solve the problem in general
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Dependent types}

  \begin{itemize}
    \item Types that can depend on or vary with values
    \item $\mathit{List_A}(n)$ -- type of lists over a type $A$ with length $n$
    \item $\Pi n : \mathbb{N}.List_\mathbb{N}(n)$ -- type of function taking a
      natural number $n$ and returning a list of natural numbers with length
      $n$ (dependent function type, dependent product).
    \item $\Sigma a : A. B$ -- a pairing of $a$ with an element of $B$ where $a$
      may be used to produce it (dependent sum).
    \item Dependent types in general allow for terms of any form to be used in
      type constructors, which makes type-checking undecidable
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Specializing dependent types}

  \begin{itemize}
    \item To stay decidable allow only terms of limited form
    \item $false$, $true$, $b_1 \land b_2$, $b_1 \lor b_2$, $\neg b$
    \item $i_1 + i_2$, $i_1 - i_2$, $i_1 * i_2$, $i_1~div~i_2$, $i_1~min~i_2$,
      $i_1~max~i_2$, $abs~i$, $sign~i$, $i_1~mod~i_2$, $i_1 > i_2$, $i_1 <
      i_2$, $i_1 \ge i_2$, $i_1 \le i_2$, $i_1 = i_2$
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Implementation: DML}

  \begin{itemize}
    \item ML is the base language, type annotations are extended with dependent
      types
    \item $\mathit{List_\mathbb{N}(n)} \implies \texttt{nat list(n)}$
    \item $\Pi a: A.B \implies \texttt{\{a: atype\} btype}$
    \item $\Sigma a: A.B \implies \texttt{[a : atype] btype}$
    \item \texttt{nat = \{n int | n $\geq$ 0\}}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example: \texttt{reverse}}

  \begin{verbatim}
  fun reverse(l) = let
    fun rev(nil, ys) = ys
      | rev(x::xs, ys) = rev(xs, x::ys)
    where rev <| {m:nat} {n:nat}
      'a list(m) * 'a list(n) -> 'a list(m+n) in
    rev(l, nil)
  end
  where reverse <| {n:nat} 'a list(n) -> 'a list(n)
  \end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Constraint generation}
  \begin{verbatim}
  rev(nil, ys) = ys
  \end{verbatim}

  \begin{itemize}
    \item Generated constraint: $\forall n : nat. \exists M : nat. \exists N :
      nat. (M = 0 \land N = n \to M + N = n)$

    \item After simplification: $\forall n : nat. (0 + n = n)$
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Constraint generation cont.}

  \begin{verbatim}
  rev(x::xs, ys) = rev(xs, x::ys)
  \end{verbatim}

  \begin{itemize}
    \item Constraint:
      $\forall m : nat. \forall n : nat.(m + 1) + n = m + (n + 1)$,

    \item Solving methods: Fourier-Motzkin, simplex, etc.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Results}

  \begin{itemize}
    \item DML compiler avoids bound (tag) checks for lists of known length
    \item Set of benchmarks used, programs were extracted from SML stdlib with
      type annotations adjusted
    \item Performance increase 10-70\%, average 30\%
    \item Costs: type annotations took about 10-20\% of the code!
    \item Can be improved?
  \end{itemize}
\end{frame}

\section{Liquid Types}
\begin{frame}{Liquid Types}
  \begin{itemize}
    \item Infer dependent types automatically.
    \item Restrict refinements to conjunction of predicates and their negation (similar to predicate abstraction).
    \item E.g. $\{\nu:$ \lstinline{int} $\mid \kappa\}$, where $\kappa \in \{\bigwedge p \mid p \in P \cup \neg P\}$
  \end{itemize}
\end{frame}

\begin{frame}{Algorithm}
  The algorithm has 3 steps:
  \begin{itemize}
    \item[1)] Generate templates using standard type inference.
    \item[2)] Generate subtype constraints according to the syntax.
    \item[3)] Solve the constraints using fixpoint iteration.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example}
  \begin{lstlisting}
let max x y = if x > y then x else y
  \end{lstlisting}
  Perform standard type inference:
  \begin{itemize}
    \item $x:$ \lstinline{int} $\rightarrow y:$ \lstinline{int} $\rightarrow$ \lstinline{int}
    \item $x: \{\nu:$ \lstinline{int} $\mid \kappa_x\} \rightarrow y: \{\nu:$ \lstinline{int} $\mid \kappa_y\} \rightarrow \{\nu:$ \lstinline{int} $\mid \kappa\}$
    \item or short: $x: \kappa_x \rightarrow y: \kappa_y \rightarrow \kappa$
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example}
  \begin{lstlisting}
let max x y = if x > y then x else y
  \end{lstlisting}
  Template: $x: \kappa_x \rightarrow y: \kappa_y \rightarrow \kappa$
  \begin{itemize}
    \item[1)] $x: \kappa_x; y: \kappa_y; (x > y) \vdash \{\nu:$ \lstinline{int} $\mid \nu = x \} <: \kappa$
    \item[2)] $x: \kappa_x; y: \kappa_y; \neg(x > y) \vdash \{\nu:$ \lstinline{int} $\nu = y \} <: \kappa$
  \end{itemize}
  Solve using $P := \{x < \nu, x \le \nu, x = \nu, y < \nu, y \le \nu, y = \nu\}$:
  \begin{itemize}
    \item No restrictions on $\kappa_x$ and $\kappa_y$, so $\kappa_x := \mathtt{true}$ and $\kappa_y := \mathtt{true}$
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example}
  \begin{itemize}
    \item[1)] $x: \kappa_x; y: \kappa_y; (x > y) \vdash \{\nu:$ \lstinline{int} $\mid \nu = x \} <: \kappa$
    \item[2)] $x: \kappa_x; y: \kappa_y; \neg(x > y) \vdash \{\nu:$ \lstinline{int} $\nu = y \} <: \kappa$
  \end{itemize}
  Solve using $P := \{x < \nu, x \le \nu, x = \nu, y < \nu, y \le \nu, y = \nu\}$:
  \begin{itemize}
    \item[1)] $x > y \land \nu = x \Rightarrow \kappa$\\
      yields $\kappa := x \le \nu \land x = \nu \land y < \nu \land y \le \nu$
    \item[2)] $\neg(x > y) \land \nu = y \Rightarrow \kappa$\\
      yields $\kappa := x \le \nu \land y \le \nu \land y = \nu$
  \end{itemize}
  $\kappa := x \le \nu \land y \le \nu$ for both constraints\\
  \lstinline{max} :: $x:$ \lstinline{int} $\rightarrow y:$ \lstinline{int} $\rightarrow \{\nu:$ \lstinline{int} $\mid x \le \nu \land y \le \nu\}$
\end{frame}

\begin{frame}{Evaluation}
  \begin{itemize}
    \item Implemented in \textbf{DSolve}.
    \item Number of annotated lines compared to the \textbf{DML} project.
  \end{itemize}
  \begin{table}
    \begin{tabular}{l|r|r}
            & \textbf{DML} & \textbf{DSolve}\\
      \hline
      lines & 17\%         & $< 1$\%
    \end{tabular}
  \end{table}
  $P := \{\nu \bowtie X \mid \bowtie \in \{<, \le, =, \neq, \geq, >\}$ and $X \in \{0, \star,$ \lstinline{len} $\star\}\}$,\\
  where $\star$ can be replaced by every variable.
\end{frame}

\section{Refinement Types For Haskell}

\begin{frame}
  \frametitle{Lazy Evaluation}
  \begin{itemize}
    \item Only do computation when it is needed i.e. call-by-need
    \item Lazy evaluation makes previous approach on refinement types unsound
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example}
  Given these ..
  \begin{lstlisting}[language=haskell]
type Pos = { v:Int | v >  0 }
type Nat = { v:Int | v >= 0 }

div :: n:Nat -> d:Pos -> { v:Nat | v < n } 
(+) :: x:Int -> y:Int -> { v:Int | v = x + y }
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example}
  .. under lazy evaluation, previous approach will fail on this example:
  \begin{lstlisting}[language=haskell]
diverge :: Int -> { v:Nat | false } 

explode :: Int -> Int
explode x = let n = diverge 1 in 
            let y = 0 in 
            x `div` y
  \end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Why?}
  When checking the type of $y$, the typechecker will generate this constraint ..
  $$\mathtt{false}\wedge(y=0)\implies(v=0)\implies(v>0)$$
  .. which any SMT solver will accept.
  \begin{itemize}
    \item This is sound under eager evaluation, since evaluation never reaches call to $div$,
    \item but since $n$ is not needed, division by zero will still occur under lazy evaluation.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Idea}
  Label binders as potentially diverging; for these, we omit them in the
  constraint.  Returning to our previous example, our constraint becomes ..
  $$\mathtt{true}\wedge(y=0)\implies(v=0)\implies(v>0)$$
  .. which is now becomes invalid.
\end{frame}

\begin{frame}
  \frametitle{Solution}
  Stratified type system consisting of those who may diverge and those who may not.
  \begin{itemize}
    \item At first, all binders is labeled as potentially diverging.  This is
      sound but very imprecise!
    \item Then use termination analysis to determine which binders actually
      terminate, thus increasing precision.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Implementation and Result}
  Implemented in LIQUIDHASKELL, an SMT-based verifier for Haskell and evaluated
  on Haskell standard libraries.  The result:
  \begin{itemize}
    \item Succesfully prove that $96\%$ of recursive functions actually terminate.
    \item Needs only $1$ line of additional annotation per 100 lines of code.
  \end{itemize}
\end{frame}


\end{document}
        
