\documentclass[pdf]{beamer}
\mode<presentation>{\usetheme{Warsaw}}
\usepackage{listings}
\usepackage{amsmath, amssymb}

%% preamble
\title{Advanced Type-based Analysis}
\subtitle{Summary of Selected Papers}
\author[Nikita Ziuzin, Joachim Bard, Hizbullah Abdul Aziz]{Nikita Ziuzin\\
        Joachim Bard\\
        Hizbullah Abdul Aziz}

\AtBeginSection[]
{
  \begin{frame}{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}

\begin{document}
\begin{frame}
  \titlepage
\end{frame}


\section{Dependent Types}

\section{Liquid Types}
\begin{frame}{Liquid Types}
  \begin{itemize}
    \item Infer dependent types automatically.
    \item Restrict refinements to conjunction of predicates and their negation (similar to predicate abstraction).
    \item E.g. $\{\nu:$ \lstinline{int} $\mid \kappa\}$, where $\kappa \in \{\bigwedge p \mid p \in P \cup \neg P\}$
  \end{itemize}
\end{frame}

\begin{frame}{Algorithm}
  The algorithm has 3 steps:
  \begin{itemize}
    \item[1)] Generate templates using standard type inference.
    \item[2)] Generate subtype constraints according to the syntax.
    \item[3)] Solve the constraints using fixpoint iteration.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example}
  \begin{lstlisting}
let max x y = if x > y then x else y
  \end{lstlisting}
  Perform standard type inference:
  \begin{itemize}
    \item $x:$ \lstinline{int} $\rightarrow y:$ \lstinline{int} $\rightarrow$ \lstinline{int}
    \item $x: \{\nu:$ \lstinline{int} $\mid \kappa_x\} \rightarrow y: \{\nu:$ \lstinline{int} $\mid \kappa_y\} \rightarrow \{\nu:$ \lstinline{int} $\mid \kappa\}$
    \item or short: $x: \kappa_x \rightarrow y: \kappa_y \rightarrow \kappa$
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example}
  \begin{lstlisting}
let max x y = if x > y then x else y
  \end{lstlisting}
  Template: $x: \kappa_x \rightarrow y: \kappa_y \rightarrow \kappa$
  \begin{itemize}
    \item[1)] $x: \kappa_x; y: \kappa_y; (x > y) \vdash \{\nu:$ \lstinline{int} $\mid \nu = x \} <: \kappa$
    \item[2)] $x: \kappa_x; y: \kappa_y; \neg(x > y) \vdash \{\nu:$ \lstinline{int} $\nu = y \} <: \kappa$
  \end{itemize}
  Solve using $P := \{x < \nu, x \le \nu, x = \nu, y < \nu, y \le \nu, y = \nu\}$:
  \begin{itemize}
    \item No restrictions on $\kappa_x$ and $\kappa_y$, so $\kappa_x := \mathtt{true}$ and $\kappa_y := \mathtt{true}$
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example}
  \begin{itemize}
    \item[1)] $x: \kappa_x; y: \kappa_y; (x > y) \vdash \{\nu:$ \lstinline{int} $\mid \nu = x \} <: \kappa$
    \item[2)] $x: \kappa_x; y: \kappa_y; \neg(x > y) \vdash \{\nu:$ \lstinline{int} $\nu = y \} <: \kappa$
  \end{itemize}
  Solve using $P := \{x < \nu, x \le \nu, x = \nu, y < \nu, y \le \nu, y = \nu\}$:
  \begin{itemize}
    \item[1)] $x > y \land \nu = x \Rightarrow \kappa$\\
      yields $\kappa := x \le \nu \land x = \nu \land y < \nu \land y \le \nu$
    \item[2)] $\neg(x > y) \land \nu = y \Rightarrow \kappa$\\
      yields $\kappa := x \le \nu \land y \le \nu \land y = \nu$
  \end{itemize}
  $\kappa := x \le \nu \land y \le \nu$ for both constraints\\
  \lstinline{max} :: $x:$ \lstinline{int} $\rightarrow y:$ \lstinline{int} $\rightarrow \{\nu:$ \lstinline{int} $\mid x \le \nu \land y \le \nu\}$
\end{frame}

\begin{frame}{Evaluation}
  \begin{itemize}
    \item Implemented in \textbf{DSolve}.
    \item Number of annotated lines compared to the \textbf{DML} project.
  \end{itemize}
  \begin{table}
    \begin{tabular}{l|r|r}
            & \textbf{DML} & \textbf{DSolve}\\
      \hline
      lines & 17\%         & $< 1$\%
    \end{tabular}
  \end{table}
  $P := \{\nu \bowtie X \mid \bowtie \in \{<, \le, =, \neq, \geq, >\}$ and $X \in \{0, \star,$ \lstinline{len} $\star\}\}$,\\
  where $\star$ can be replaced by every variable.
\end{frame}

\section{Refinement Types Under Lazy Evaluation}
\begin{frame}
  \frametitle{Lazy Evaluation}
  \begin{itemize}
    \item Only do computation when it is needed i.e. call-by-need
    \item Lazy evaluation makes previous approach on refinement types unsound
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example}
  Given these ..
  \begin{lstlisting}[language=haskell]
type Pos = { v:Int | v >  0 }
type Nat = { v:Int | v >= 0 }

div :: n:Nat -> d:Pos -> { v:Nat | v < n } 
(+) :: x:Int -> y:Int -> { v:Int | v = x + y }
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example}
  .. under lazy evaluation, previous approach will fail on this example:
  \begin{lstlisting}[language=haskell]
diverge :: Int -> { v:Nat | false } 

explode :: Int -> Int
explode x = let n = diverge 1 in 
            let y = 0 in 
            x `div` y
  \end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Why?}
  When checking the type of $y$, the typechecker will generate this constraint ..
  $$\mathtt{false}\wedge(y=0)\implies(v=0)\implies(v>0)$$
  .. which any SMT solver will accept.
  \begin{itemize}
    \item This is sound under eager evaluation, since evaluation never reaches call to $div$,
    \item but since $n$ is not needed, division by zero will still occur under lazy evaluation.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Idea}
  Label binders as potentially diverging; for these, we omit them in the
  constraint.  Returning to our previous example, our constraint becomes ..
  $$\mathtt{true}\wedge(y=0)\implies(v=0)\implies(v>0)$$
  .. which is now becomes invalid.
\end{frame}

\begin{frame}
  \frametitle{Solution}
  Stratified type system consisting of those who may diverge and those who may not.
  \begin{itemize}
    \item At first, all binders is labeled as potentially diverging.  This is
      sound but very imprecise!
    \item Then use termination analysis to determine which binders actually
      terminate, thus increasing precision.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Implementation and Result}
  Implemented in LIQUIDHASKELL, an SMT-based verifier for Haskell and evaluated
  on Haskell standard libraries.  The result:
  \begin{itemize}
    \item Succesfully prove that $96\%$ of recursive functions actually terminate.
    \item Needs only $1$ line of additional annotation per 100 lines of code.
  \end{itemize}
\end{frame}


\end{document}
        
